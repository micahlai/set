<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set Card Game - Online Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .menu {
            text-align: center;
        }

        .input-group {
            margin: 20px 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        input {
            width: 100%;
            max-width: 400px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-area {
            display: none;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .scoreboard {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .player-score {
            text-align: center;
        }

        .player-score .name {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .player-score .score {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .cards-remaining {
            font-size: 18px;
            color: #666;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .card {
            aspect-ratio: 2/3;
            border: 3px solid #ddd;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
            transition: all 0.3s;
            position: relative;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .card.selected {
            border-color: #667eea;
            border-width: 4px;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .card svg {
            width: 80%;
            height: auto;
            margin: 5px 0;
        }

        .status {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            font-weight: bold;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .room-code {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .room-code code {
            background: #e9ecef;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            display: inline-block;
            cursor: pointer;
            user-select: all;
            letter-spacing: 5px;
        }

        .room-code code:hover {
            background: #dee2e6;
        }

        .connection-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .connection-status.online {
            background: #28a745;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .players-waiting {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .player-list {
            list-style: none;
            padding: 10px 0;
        }

        .player-list li {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 1.8em;
            }

            .game-info {
                flex-direction: column;
                gap: 15px;
            }

            .board {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 10px;
            }

            .room-code code {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ´ Set Card Game</h1>
        
        <div id="menu" class="menu">
            <div class="input-group">
                <label for="username">Your Username:</label>
                <input type="text" id="username" placeholder="Enter your name" maxlength="20">
            </div>
            
            <button onclick="createRoom()">Create New Room</button>
            
            <div class="input-group" style="margin-top: 30px;">
                <label for="roomCode">Or Join Existing Room:</label>
                <input type="text" id="roomCode" placeholder="Enter 4-digit code" maxlength="4" style="text-transform: uppercase;">
            </div>
            
            <button onclick="joinRoom()">Join Room</button>
            
            <div id="menuStatus" class="status" style="display:none;"></div>
        </div>

        <div id="waitingRoom" style="display:none;">
            <div class="room-code">
                <p><span class="connection-status online"></span>Room is Active</p>
                <p style="margin: 10px 0;">Room Code:</p>
                <code id="displayRoomCode" onclick="copyRoomCode()"></code>
                <p style="margin-top: 10px; color: #666; font-size: 14px;">
                    Click code to copy â€¢ Share with friends!
                </p>
            </div>
            
            <div class="players-waiting">
                <h3>Players in Room:</h3>
                <ul id="playerList" class="player-list"></ul>
            </div>
            
            <button onclick="startGame()" id="startButton">Start Game</button>
            <button onclick="leaveRoom()">Leave Room</button>
        </div>

        <div id="gameArea" class="game-area">
            <div class="game-info">
                <div class="scoreboard" id="scoreboard"></div>
                <div class="cards-remaining">
                    Cards in deck: <span id="cardsRemaining">69</span>
                </div>
            </div>
            
            <div id="status" class="status" style="display:none;"></div>
            
            <div id="board" class="board"></div>
            
            <button onclick="leaveGame()">Leave Game</button>
        </div>
    </div>

    <script type="module">
        // Backend API configuration
        // REPLACE THIS URL with your Railway deployment URL after deploying
        const API_URL = 'https://set-production-c246.up.railway.app';
        
        let pollInterval;
        let gameState = {
            deck: [],
            board: [],
            players: {},
            selectedCards: [],
            myName: '',
            roomCode: '',
            gameStarted: false,
            isHost: false,
            lastUpdate: Date.now()
        };

        const numbers = [1, 2, 3];
        const shapes = ['oval', 'squiggle', 'diamond'];
        const colors = ['red', 'green', 'purple'];
        const shadings = ['solid', 'striped', 'open'];

        function generateDeck() {
            const deck = [];
            for (let num of numbers) {
                for (let shape of shapes) {
                    for (let color of colors) {
                        for (let shading of shadings) {
                            deck.push({ number: num, shape, color, shading });
                        }
                    }
                }
            }
            return shuffle(deck);
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += chars[Math.floor(Math.random() * chars.length)];
            }
            return code;
        }

        // Simplified local-only multiplayer for demo
        // For a production version, you'd need to set up your own backend

        async function createRoomOnServer() {
            const roomData = {
                players: gameState.players,
                gameStarted: false,
                deck: [],
                board: [],
                selectedCards: [],
                lastUpdate: Date.now()
            };

            try {
                const response = await fetch(`${API_URL}/room/${gameState.roomCode}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(roomData)
                });
                return response.ok;
            } catch (error) {
                console.error('Error creating room:', error);
                return false;
            }
        }

        async function updateRoomOnServer() {
            const roomData = {
                players: gameState.players,
                gameStarted: gameState.gameStarted,
                deck: gameState.deck,
                board: gameState.board,
                selectedCards: gameState.selectedCards,
                lastUpdate: Date.now()
            };

            try {
                await fetch(`${API_URL}/room/${gameState.roomCode}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(roomData)
                });
            } catch (error) {
                console.error('Error updating room:', error);
            }
        }

        async function getRoomFromServer() {
            try {
                const response = await fetch(`${API_URL}/room/${gameState.roomCode}`);
                if (!response.ok) return null;
                return await response.json();
            } catch (error) {
                console.error('Error fetching room:', error);
                return null;
            }
        }

        async function checkRoomExists() {
            try {
                const response = await fetch(`${API_URL}/room/${gameState.roomCode}/exists`);
                const data = await response.json();
                return data.exists;
            } catch (error) {
                console.error('Error checking room:', error);
                return false;
            }
        }

        window.createRoom = async function() {
            const username = document.getElementById('username').value.trim();
            if (!username) {
                showMenuStatus('Please enter a username', 'error');
                return;
            }

            gameState.myName = username;
            gameState.isHost = true;
            gameState.roomCode = generateRoomCode();
            gameState.players[username] = { score: 0, isHost: true };

            showMenuStatus('Creating room...', 'info');

            const success = await createRoomOnServer();
            if (!success) {
                showMenuStatus('Error creating room. Make sure backend is running.', 'error');
                return;
            }

            showWaitingRoom();
            startPolling();
        };

        window.joinRoom = async function() {
            const username = document.getElementById('username').value.trim();
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();
            
            if (!username || !roomCode) {
                showMenuStatus('Please enter username and room code', 'error');
                return;
            }

            if (roomCode.length !== 4) {
                showMenuStatus('Room code must be 4 characters', 'error');
                return;
            }

            showMenuStatus('Joining room...', 'info');

            gameState.roomCode = roomCode;
            
            const exists = await checkRoomExists();
            if (!exists) {
                showMenuStatus('Room not found. Check the code and try again.', 'error');
                return;
            }

            const roomData = await getRoomFromServer();
            if (!roomData) {
                showMenuStatus('Error joining room.', 'error');
                return;
            }

            gameState.myName = username;
            gameState.isHost = false;
            
            roomData.players[username] = { score: 0, isHost: false };
            roomData.lastUpdate = Date.now();
            
            gameState.players = roomData.players;
            gameState.deck = roomData.deck;
            gameState.board = roomData.board;
            gameState.selectedCards = roomData.selectedCards || [];
            gameState.gameStarted = roomData.gameStarted;

            await updateRoomOnServer();
            
            if (gameState.gameStarted) {
                showGameArea();
                renderBoard();
                updateScoreboard();
            } else {
                showWaitingRoom();
            }
            
            startPolling();
        };

        function startPolling() {
            pollInterval = setInterval(async () => {
                const roomData = await getRoomFromServer();
                if (!roomData) return;

                // Sync game state
                if (roomData.lastUpdate > gameState.lastUpdate) {
                    gameState.players = roomData.players;
                    gameState.deck = roomData.deck;
                    gameState.board = roomData.board;
                    gameState.selectedCards = roomData.selectedCards || [];
                    gameState.lastUpdate = roomData.lastUpdate;

                    if (roomData.gameStarted && !gameState.gameStarted) {
                        gameState.gameStarted = true;
                        showGameArea();
                        renderBoard();
                        updateScoreboard();
                    } else if (gameState.gameStarted) {
                        renderBoard();
                        updateScoreboard();
                    } else {
                        updatePlayerList();
                    }
                }
            }, 1000); // Poll every second
        }

        async function updateRoom() {
            await updateRoomOnServer();
        }

        window.startGame = function() {
            if (Object.keys(gameState.players).length < 1) {
                showMenuStatus('Need at least 1 player to start', 'error');
                return;
            }

            gameState.deck = generateDeck();
            gameState.board = gameState.deck.splice(0, 12);
            gameState.gameStarted = true;

            updateRoom();

            showGameArea();
            renderBoard();
            updateScoreboard();
        };

        window.selectCard = function(index) {
            if (!gameState.gameStarted) return;
            
            const cardIndex = gameState.selectedCards.indexOf(index);
            
            if (cardIndex > -1) {
                gameState.selectedCards.splice(cardIndex, 1);
            } else {
                if (gameState.selectedCards.length < 3) {
                    gameState.selectedCards.push(index);
                }
            }

            renderBoard();
            updateRoom();

            if (gameState.selectedCards.length === 3) {
                setTimeout(() => checkSet(), 300);
            }
        };

        function checkSet() {
            const cards = gameState.selectedCards.map(i => gameState.board[i]);
            
            const isValidSet = 
                checkAttribute(cards, 'number') &&
                checkAttribute(cards, 'shape') &&
                checkAttribute(cards, 'color') &&
                checkAttribute(cards, 'shading');

            if (isValidSet) {
                gameState.players[gameState.myName].score += 3;
                
                gameState.selectedCards.sort((a, b) => b - a);
                for (let index of gameState.selectedCards) {
                    if (gameState.deck.length > 0) {
                        gameState.board[index] = gameState.deck.pop();
                    } else {
                        gameState.board.splice(index, 1);
                    }
                }

                showStatus('Valid set! +3 points', 'success');
            } else {
                if (gameState.board.length > 0) {
                    const returnIndex = Math.floor(Math.random() * gameState.board.length);
                    const returnedCard = gameState.board.splice(returnIndex, 1)[0];
                    gameState.deck.push(returnedCard);
                }

                showStatus('Not a valid set! Card returned to deck', 'error');
            }

            gameState.selectedCards = [];
            renderBoard();
            updateScoreboard();
            updateRoom();
            checkGameEnd();
        }

        function checkAttribute(cards, attr) {
            const values = cards.map(c => c[attr]);
            const allSame = values.every(v => v === values[0]);
            const allDifferent = new Set(values).size === 3;
            return allSame || allDifferent;
        }

        function checkGameEnd() {
            if (gameState.deck.length === 0 && gameState.board.length === 0) {
                const winner = Object.entries(gameState.players)
                    .sort((a, b) => b[1].score - a[1].score)[0];
                showStatus(`Game Over! ${winner[0]} wins with ${winner[1].score} points!`, 'success');
            }
        }

        function renderBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';
            
            gameState.board.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'card';
                if (gameState.selectedCards.includes(index)) {
                    cardEl.classList.add('selected');
                }
                cardEl.onclick = () => window.selectCard(index);
                
                for (let i = 0; i < card.number; i++) {
                    cardEl.appendChild(createShape(card.shape, card.color, card.shading));
                }
                
                board.appendChild(cardEl);
            });

            document.getElementById('cardsRemaining').textContent = gameState.deck.length;
        }

        function createShape(shape, color, shading) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 50');
            svg.style.width = '100%';
            svg.style.height = 'auto';

            let path;
            if (shape === 'oval') {
                path = 'M 10 25 Q 10 10 25 10 L 75 10 Q 90 10 90 25 Q 90 40 75 40 L 25 40 Q 10 40 10 25';
            } else if (shape === 'diamond') {
                path = 'M 50 5 L 90 25 L 50 45 L 10 25 Z';
            } else {
                path = 'M 20 25 Q 20 10 35 15 Q 50 20 65 10 Q 80 5 80 20 Q 80 35 65 30 Q 50 25 35 35 Q 20 40 20 25';
            }

            const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathEl.setAttribute('d', path);
            pathEl.setAttribute('stroke', color);
            pathEl.setAttribute('stroke-width', '2');

            if (shading === 'solid') {
                pathEl.setAttribute('fill', color);
            } else if (shading === 'striped') {
                const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                const patternId = `stripe-${shape}-${color}-${Math.random()}`;
                pattern.setAttribute('id', patternId);
                pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                pattern.setAttribute('width', '4');
                pattern.setAttribute('height', '4');
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '0');
                line.setAttribute('y1', '0');
                line.setAttribute('x2', '0');
                line.setAttribute('y2', '4');
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', '1');
                
                pattern.appendChild(line);
                svg.appendChild(pattern);
                pathEl.setAttribute('fill', `url(#${patternId})`);
            } else {
                pathEl.setAttribute('fill', 'none');
            }

            svg.appendChild(pathEl);
            return svg;
        }

        function updateScoreboard() {
            const scoreboard = document.getElementById('scoreboard');
            scoreboard.innerHTML = '';
            
            Object.entries(gameState.players).forEach(([name, data]) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-score';
                playerDiv.innerHTML = `
                    <div class="name">${name}${name === gameState.myName ? ' (You)' : ''}</div>
                    <div class="score">${data.score}</div>
                `;
                scoreboard.appendChild(playerDiv);
            });
        }

        function updatePlayerList() {
            const list = document.getElementById('playerList');
            list.innerHTML = '';
            
            Object.keys(gameState.players).forEach(name => {
                const li = document.createElement('li');
                li.textContent = name + (name === gameState.myName ? ' (You)' : '');
                list.appendChild(li);
            });
        }

        function showWaitingRoom() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('waitingRoom').style.display = 'block';
            document.getElementById('displayRoomCode').textContent = gameState.roomCode;
            updatePlayerList();
            
            if (!gameState.isHost) {
                document.getElementById('startButton').style.display = 'none';
            }
        }

        function showGameArea() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('waitingRoom').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';
        }

        function showMenuStatus(message, type) {
            const status = document.getElementById('menuStatus');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 3000);
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 3000);
        }

        window.leaveRoom = function() {
            if (pollInterval) clearInterval(pollInterval);
            location.reload();
        };

        window.leaveGame = function() {
            if (pollInterval) clearInterval(pollInterval);
            location.reload();
        };

        window.copyRoomCode = function() {
            const code = document.getElementById('displayRoomCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showMenuStatus('Room code copied to clipboard!', 'success');
            }).catch(() => {
                const range = document.createRange();
                range.selectNodeContents(document.getElementById('displayRoomCode'));
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            });
        };
    </script>
</body>
</html>